"use strict";

const conversions = require("webidl-conversions");
const utils = require("./utils.js");

const convertBlob = require("./Blob.js").convert;
const impl = utils.implSymbol;
const EventTarget = require("./EventTarget.js");

module.exports = {
  createInterface: function(defaultPrivateData = {}) {
    function FileReader() {
      if (new.target === undefined) {
        throw new TypeError(
          "Failed to construct 'FileReader'. Please use the 'new' operator; this constructor " +
            "cannot be called as a function."
        );
      }

      iface.setup(this);
    }

    Object.setPrototypeOf(FileReader.prototype, EventTarget.interface.prototype);
    Object.setPrototypeOf(FileReader, EventTarget.interface);

    Object.defineProperty(FileReader, "prototype", {
      value: FileReader.prototype,
      writable: false,
      enumerable: false,
      configurable: false
    });

    FileReader.prototype.readAsArrayBuffer = function readAsArrayBuffer(blob) {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }

      if (arguments.length < 1) {
        throw new TypeError(
          "Failed to execute 'readAsArrayBuffer' on 'FileReader': 1 argument required, but only " +
            arguments.length +
            " present."
        );
      }
      const args = [];
      {
        let curArg = arguments[0];
        curArg = convertBlob(curArg, { context: "Failed to execute 'readAsArrayBuffer' on 'FileReader': parameter 1" });
        args.push(curArg);
      }
      return this[impl].readAsArrayBuffer(...args);
    };

    FileReader.prototype.readAsBinaryString = function readAsBinaryString(blob) {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }

      if (arguments.length < 1) {
       